# -*- coding: utf-8 -*-
"""MATH_424_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ve0K2C5HodB7-Ov0UuXyBqNWblEAbufs
"""

import matplotlib.pyplot as plt
import numpy as np
import skimage

def display_image(img, bw=False, title=""):
  if(bw): plt.imshow(img, cmap=plt.cm.gray)
  else: plt.imshow(img)
  plt.title(title)
  plt.show()

def xor(arr1, arr2):
  # Check if the input arrays have the same shape
  if arr1.shape != arr2.shape:
      raise ValueError("Input arrays must have the same shape")

  # Create an empty array to store the result
  result = np.empty_like(arr1, dtype=arr1.dtype)

  # Apply bitwise XOR element-wise
  for i in range(arr1.shape[0]):
      for j in range(arr1.shape[1]):
          result[i, j] = arr1[i, j] ^ arr2[i, j]

  return result

def img_hist(img):
  plt.hist(img.ravel(), bins=256)
  plt.show()

# display_image(skimage.data.astronaut())
image = skimage.data.astronaut()
print((image[0]))
# random_key = np.random.randint(0, 256, size=image.shape, dtype=np.uint8)
# encrypted_image = encrypt(image, random_key)
# modify(encrypted_image, random_key)
# display_image(encrypted_image)
# # img_hist(encrypted_image)
# display_image(encrypt(encrypted_image, random_key))
# # img_hist(encrypted_image)
# # image = modify(encrypted_image)
# # display_image(encrypt(encrypted_image, random_key))

import math
import random

def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, x, y = extended_gcd(b % a, a)
        return g, y - (b // a) * x, x

def modinv(a, m):
    g, x, _ = extended_gcd(a, m)
    if g != 1:
        raise ValueError(f"The modular inverse does not exist for {a} modulo {m}")
    else:
        return (x % m + m) % m

def key_gen():
  bits = 16
  p = 149; q = 197
  n = p*q
  n2 = n*n
  l = math.lcm((p-1),(q-1))
  g = 56602 # (random) length of bits (16)

  def L(u,n):
    return (u-1) // n
  u = modinv(L(pow(g,l,n2), n), n)
  return g,n,n2,l,u

def encrypt(m):
  r = random.randint(1,n-1)

  result = pow(g,m,n2)
  x = pow(r,n,n2)
  result = (result * x) % n2

  return result

def decrypt(c):
  p = (((pow(c,l,n2) - 1) // n) * u) % n
  # print("p", p)
  return p

def modify(c, val):
  return (c * encrypt(val)) % n2

# g = 46822
# n = 48443
# n2 = 2346724249
# l = 24000
# u = 3390

g,n,n2,l,u = key_gen()

c1 = encrypt(10)
print("c1", c1)
c2 = encrypt(165)
print("c2", c2)
print("c2 mod 255", c2 % 255)
print("c2 w 255", ((c2 % 255) * 255))
# prod = (c1 * c2) % n2
prod = modify(c1, 165)
print(prod)
decrypt(prod)

def ImgEncrypt(image):
    """
    args:
        public_key: Paillier PublicKey object
        plainimg: PIL Image object

    returns:
        cipherimg: Encryption of plainimg
    Encrypts an image
    """


    shape = image.shape
    print(shape)
    image = image.flatten().tolist()
    print(type(image))
    image = [encrypt(pix) for pix in image]
    # print(image.shape)

    return np.asarray(image).reshape(shape)

def ImgDecrypt(cipherimg):
    """
    args:
        public_key: Paillier PublicKey object
        private_key: Paillier PrivateKey object
        cipherimg: encryption of Image

    returns:
        Image object which is the decryption of cipherimage
    Decrypts ecnrypted image
    """
    shape = cipherimg.shape
    print(shape)
    plainimg = cipherimg.flatten().tolist()
    image = [decrypt(pix) for pix in plainimg]
    image = [pix if pix < 255 else 255 for pix in image]
    image = [pix if pix > 0 else 0 for pix in image]
    # plainimg = [Paillier.Decrypt(public_key, private_key, pix) for pix in plainimg]
    # plainimg = [pix if pix < 255 else 255 for pix in plainimg]
    # plainimg = [pix if pix > 0 else 0 for pix in plainimg]

    return np.asarray(image).reshape(shape)

img = skimage.data.astronaut()
# test_shape = (10,10)
# img = np.random.randint(0, 256, size=test_shape, dtype=np.uint8)
# display_image(img)
enc = ImgEncrypt(img)
# display_image(enc)
dec = ImgDecrypt(enc)
# display_image()

def ImgModify(cipherimg):
  shape = cipherimg.shape
  # num = 457967532 # (10)
  modimg = cipherimg.flatten().tolist()
  modimg = [modify(pix, 100) for pix in modimg]
  return np.asarray(modimg).reshape(shape)

mod_img = ImgModify(enc)
mod_img_dec = ImgDecrypt(mod_img)

from sklearn.metrics import mean_squared_error
# print(enc)
# print(dec)
# img_hist(enc)
display_image((mod_img - enc) % 255)
img_hist((enc - mod_img) % 255)
# img_hist((enc-mod_img))
# display_image(enc % 255)
img_hist(mod_img_dec)
# display_image(dec)
# img_hist(dec-img)
# print(img)
# print(dec)
# print(np.count_nonzero(dec > 255))

def PSNR(original, compressed):
    mse = np.mean((original - compressed) ** 2)
    if(mse == 0):  # MSE is zero means no noise is present in the signal .
                  # Therefore PSNR have no importance.
        return 100
    max_pixel = 255.0
    psnr = 20 * math.log10(max_pixel / math.sqrt(mse))
    return psnr

PSNR(img, enc)
# np.cov(img.flatten(), enc.flatten())

# mean_squared_error(img.flatten(), enc.flatten())
# mean_squared_error(ImgDecrypt(mod_img).flatten(), (img+10).flatten())

"""Some encryption function is called for each bit? Or does the encryption function get an entire row and balance that?

Stego embedding?
"""

# int gcd(int a, int b, int *x, int *y) {
#     if (a == 0) {
#         *x = 0;
#         *y = 1;
#         return b;
#     }

#     int x1, y1;
#     int gcd_value = gcd(b % a, a, &x1, &y1);

#     *x = y1 - (b / a) * x1;
#     *y = x1;

#     return gcd_value;
# }

# // Function to calculate the modular inverse of a modulo m
# int modinv(int a, int m) {
#     int x, y;
#     int gcd_value = gcd(a, m, &x, &y);

#     if (gcd_value != 1) {
#         // Modular inverse does not exist
#         return -1;
#     }

#     // Ensure the result is positive
#     return (x % m + m) % m;
# }